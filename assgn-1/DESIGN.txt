The idea behind my design is to take care of the simple cases first. If it is not a simple case, then I call a function that takes care of the input. I have a main method in which most of my code is run. I parse each and every character from the input. Commands are inputed by the user when they type in the shell. The input can then be parsed later in the form of an array and I implement a if elseif else idea to check for each type of input.

I first check if a "|" exists in my input that is provided my getInput() function (provided by Professor Long). If it exists, then I call my piping function and set the flag to true. Next, I take care of the ">" character. If the output character exists, I do some error checking to see if there is a file to append to or not. I also am checking if there is another ">" to see if I am appending or just redirecting to a file. I copy the file names I am appending or rewriting to and continue. Based on the input, I then call my functions appropriately, which I will go into more detail later.

I then take care of the case where I am taking an input and outputting to a file. This would look something like "sort < file1 > file2". Once again, I am parsing the args array seeking if the "<" and ">" character both exist. If not, I do the appropriate error checking. I also copy the file name of the output file I am writing to into a char buffer. I then call the inputToOutput function.

My next check is for just solely the "<" character. If this is found, then I do the appropriate error checking to see if a file is being inputted and call my sortCommand() function.

While I do all of these checks in a if elseif else manner, I set a flag each time to check if any of my specifc functions are being called. If none of my specific functions are being called I have a case where I just do regular commands that can be run using execvp. These type of commands do not require an input or output. This is also implemented using a if else else manner because I have 3 more cases, where two of them aren't taken care of by execvp. In the first case, when i type in exit, I should exit the shell and free up all memory from lex.yy.c. In the next case, I am taking care of the "cd" command which is not taken care of by execvp. Here, I call a helper method that takes care of its implementation. Lastly, in my else case, I do regular commands by forking a child process and running execvp in my child process. I also do the appropriate error checking. We are now at the bottom of my giant main function, so I reset all flags and the while(1) will take me back to the next iteration of the loop.

Now, I will go over my helper functions. I have one for cd in which I get my home directory when I first run my shell, so i can cd to my home directory. I also use chdir to move to a different directory. 

I have a redirectFile() function that forks a child process and appends to file if the flag is set or just redirects stdout to a output file. I call execvp by setting the ">" character to null, so execvp runs from args[0] and terminates at the null character. I am calling waitpid in my parent process so I wait for my child process to terminate.

My sortCommand() function is similar to my redirectFile() function. This time I close stdin and read from an input file using dup. Dup duplicates the file descriptor I get when I call open. Here, I set the "<" character to null, and call execvp from args[0]. It once again terminates on the null character. 

My next function is the inputToOutput() function. This function combines both of the previous functions. I first check if I am appending to a file and if I am, I add the appropriate flags to the open function. Else, I do normal input to output redirection. I close stdin, get my input, close stdout, and write out to a file. I also make sure to set the "<" and ">" to null, so when I call execvp, it terminates on the null.

The last helper function I have is the pipeCommand() function. Here, I am creating a 2-D array based on my number of pipes. The row would be the pipe and column would be stdin or stdout. I am then iterate through the commands in a while loop until I reach the end of the input. I implement a switch statement when I encounter a "|" that takes me to my case provided by the forked process id. Each time I encounter a '|', I set it to null and get the index of the next command, so I know where to begin next. Next, in my case 0, I have two if statements that check if im not on my first command and if im not on my last command. If I am not in my first command I get input from the stdin of the pipe of the previous command and write it to stdout of my current pipe. If it is the last command, I also check if I have to write it out to a file. In my next if statement, I am checking if I am not on my last command. Here, I get close stdout and write to my current pipe. Basically, I have three cases: if I am on my first command, middle command, or last command. However, I know there is repetitve code here, so I just used two cases: if i am not on my first command, if i am not on my last command. I then call execvp in the child process and close all my pipes in the child process. Next, I get the nextCommand index and increment to the next command and increment the counterForCommandsFinished. I have an if statement towards the end to check if I am on my last command and set a flag accordingly for my switch statement. Lastly, I close all pipes in my parent process and call wait to wait for all child processes to complete. 

This is an overall rundown of my code, where the key idea was to have a main and implement checks and call helper functions. The shell ends when you type exit. 

